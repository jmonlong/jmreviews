---
date: 2016-08-17
title: Local assembly
tags: ['literature']
output: blogdown::html_page
---

## TIGRA: A targeted iterative graph routing assembler for breakpoint assembly

by Ken Chen et al, [Genome Research 2014](http://www.ncbi.nlm.nih.gov/pubmed/24307552).

*Targeted Iterative Graph Routing Assembler* was widely used in large-scale projects (e.g. 1KGP) for **breakpoints assembly of deletions and mobile element insertion**. 
It's an old effort, that they started in 2008, which was optimized and improved across the years. 

To clarify, TIGRA assembles the breakpoint region of SV, **not the entire SV region**. 
Another clarification: TIGRA is used to **validate existing calls** and reduce the FDR, not so much to characterize SV mechanism or features.

1. **Reads are extracted** around the predicted breakpoint (+- 500bp-1Kbp). 
    + Mapped reads *and their mate* are retrieved from the BAM files. 
    + If multiple samples are available and their genotype is known, reads from the variant-containing samples can be pooled. 
2. Reads are **assembled** using a de Bruijn graph. 
    + Multiple k-mer sizes are *iteratively* used (starting from small k-mers).
    + Previously assembled contigs taken as *pseudo-reads* in the next iterations. 
    + Tips, likely created by sequencing errors, are pruned. 
	+ Bubbles are joined when the size difference is lower than 3 nucleotides. 
	+ *Entire reads* are used to distinguish repeats, instead of k-mers. 
3. Assembled sequences are **mapped back to the reference genome** using [cross_match](http://www.phrap.org/phredphrapconsed.html).
    + Every contig is tested although they don't explain explicitly how these contigs are retrieved from the graph. 
    + Contigs with more than two hits or substitution rate higher than 0.5% (low isn't it ?) are not reported. 
    + A *glocal* alignment is used. 

They tested TIGRA assembly step against Velvet, SGA, Phrap and SPAdes. 
They used datasets with known deletions breakpoints and mobile element insertions. 
TIGRA shows the *highest proportion of validated SVs* in any situations.
The validation rates are lower than I thought (40%-80%) but it might reflect the low sequencing depth.
They also managed to detect quasi-full length Alu insertion (Was it because they knew it was there ?).
TIGRA is more robust to low-coverage alleles than other existing methods, thanks to its multiple k-mer size process. 

It seems mainly **focused on deletions, duplication (not benchmarked) and mobile insertion**, although they mention being able to detect any type of de novo SV and having specific strategies to deal with inversion or reciprocal translocations. 

While it handles repeats slightly better than other methods, by using full reads instead of k-mers, repeated sequences longer than the read length will not be resolved and are bound to create ambiguous graphs. 
Indeed they observed a reduction of assembled breakpoints with higher breakpoint homology. 
It is implemented to assemble small breakpoint regions, hence **require almost nucleotide resolution as input**. 

+ They mention an important drop in validation rate for RD-based regions. Is it because of the input breakpoints being less precise ?
+ I didn't understand how they define their contigs (used in the iterative process; aligned against the reference). Is it all possible paths in the graph ? Only unambiguous paths ?

TIGRA is available here: [http://bioinformatics.mdanderson.org/main/TIGRA](http://bioinformatics.mdanderson.org/main/TIGRA).

## Breakpoint profiling of 64 cancer genomes reveals numerous complex rearrangements spawned by homology-independent mechanisms.

by Malhotra et al, [Genome Research 2013](http://www.pubmedcentral.nih.gov/articlerender.fcgi?artid=3638133&tool=pmcentrez&rendertype=abstract).

In this study, they looked at 64 genomes from 7 different cancers and tried to characterize the breakpoints of somatic SVs. 
Here, I'll focus on the local assembly part of the paper. 

They **modified SGA assembler** ([Simpson and Durbin 2012](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3290790/)) to **report all paths** from all connected components from the string graph.

1. Extracted read pairs around the breakpoint (+- 500 bp).
2. Assembly: *sga preprocess*, *sga index*, *sga correct*, *sga index*, *sga rmdup*, *sga overlap*, *sga assemble*, modified *sga walk*.
3. Contig aligned on reference using BWA-SW.
4. Split-mapping with >25bp non-overlap with adjacent mapping.
5. Comparison with original SV signature

Consistent with TIGRA benchmark, they estimate their validation rate around 80% for deletion.
They mention that deletion are the easiest to validate and expect lower overall validation rate.

+ How does this perform in regions with repeats ?
+ How does it scale up when assembling larger regions ?

## Discovery and characterization of Alu repeat sequences via precise local read assembly

by Wildschutte et al, [*Nucleic Acids Res.* 2015](http://www.ncbi.nlm.nih.gov/pubmed/26503250).

Jeff Kidd's group built on existing approaches to **detect Alu insertion** and attempted to **assemble the full allelic sequence**.

1. Retro-Seq selected **insertion-supporting reads**.
    + One pair mapped uniquely, the other in Alu consensus or instance.
    + Minimum of 2 supporting reads per call.
	+ Call *within 500 bp of existing Alu were removed*.
2. Reads for each insertion were **assembled with CAP3** (overlap-layout-consensus).
    + Read pair within 200 bp and with soft-clip > 20 bp were added.
	+ CAP3 uses read-pair information and links contigs.
	+ They keep sequence with at least 30 bp of Alu and 30 bp of non-gapped sequence..
3. **Breakpoint determination** using a suite of (old) programs.
    + Orientation guessed by a *BLAT* on the reference.
	+ Candidate breakpoints from *miropeats* (semi-automated graphical alignment).
	+ Global alignment of the insertion breakpoints using *stretcher* (to see TSD).
	+ A lot of *manual review/curation* in the end.

Pipeline available on GitHub: [https://github.com/KiddLab/insertion-assembly](https://github.com/KiddLab/insertion-assembly).

## Enhanced structural variant and breakpoint detection using SVMerge by integration of multiple detection methods and local assembly.

by Wong et al, [Genome Biology 2010](http://www.pubmedcentral.nih.gov/articlerender.fcgi?artid=3046488{&}tool=pmcentrez{&}rendertype=abstract).

SVMerge is a pipeline that:

1. Makes SV prediction with a collection of callers.
2. Filter them
3. Merge them.
4. Validate them using local assembly.

For the assembly step: 

1. Reads around the breakpoint are extracted (+- 1-2 kbp).
    + Mapped read and mate pair.
	+ Reads were written in FASTA with interleaved read pairs (Velvet input?).
	+ SV discarded if too many reads.
1. Assembly using ABySS or Velvet.
    + With and without scaffolding.
	+ All contigs were considered.
1. Contig alignment using Exonerate.
1. Alignment parsing.
    + To verify the breakpoint location.
    + To verify read depth change (het deletions).

Perl scripts available here: [http://svmerge.sourceforge.net/](http://svmerge.sourceforge.net/).

## Other SV-assembler to check

+ laSV: [Local sequence assembly reveals a high-resolution profile of somatic structural variations in 97 cancer genomes](http://nar.oxfordjournals.org/lookup/doi/10.1093/nar/gkv831).
+ AsmVar: [Discovery, genotyping and characterization of structural variation and novel sequence at single nucleotide resolution from de novo genome assemblies on a population scale](http://www.gigasciencejournal.com/content/4/1/64).
+ CREST: [CREST maps somatic structural variation in cancer genomes with base-pair resolution. Wang et al. Nat Methods. 2011](http://www.pubmedcentral.nih.gov/articlerender.fcgi?artid=3527068&tool=pmcentrez&rendertype=abstract).
+ SV-STAT: [SV-STAT accurately detects structural variation via alignment to reference-based assemblies](http://scfbm.biomedcentral.com/articles/10.1186/s13029-016-0051-0)
+ PopIns: [PopIns: population-scale detection of novel sequence insertions](http://bioinformatics.oxfordjournals.org/cgi/doi/10.1093/bioinformatics/btv273).
