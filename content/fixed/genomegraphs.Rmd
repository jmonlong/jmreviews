---
sidebar: true
title: Genome Graphs
bibliography: [../../library-small.bib]
link-citations: true
weight: 5
output:
  blogdown::html_page:
    toc: true
---


@Paten2017 wrote a review on genome graphs covering a large number of topics.
@Marschall2018 review the emergent field of computational pan-genomics.

# Types of graphs

In @Novak2017, several genome graphs structures are compared and shown to be superior to linear representations when mapping reads.

# Pangenome construction

- kmer/de bruijn graph
    - Pantools
    - Bifrost
- sequence graphs
  - PGGB
  - TwoPaco
  - Minigraph
  - Minigraph-Cactus

Andreace et al. compared five tools to make human pangenome graphs [@andreace2023].
`Bifrost` and `mdbg` build kmers/minimizers graphs.
`Minigraph`, `Minigraph-Cactus`, `pggb` build sequence graphs.
They used 52 phased assemblies (HPRC + 5 haplotypes from the DeepConsensus paper), plus GRCh38 and CHM13.
They tested the tools at different scales (2, 10, 104 haplotypes) and changing the order of the inputs.
Potentially important note, `mdbg` is the tool from the author of this comparison work.
For all tools, the graph complexity grew only by a factor of 5 going from 10 to 104 haplotypes.
They compare the graphs in some complex relevant loci (e.g. HLA).
Each tools was also graded on eight features (stability, editability, downstream applications, compression, visualization, annotation).
I'm suprised that Minigraph-Cactus makes slightly different graphs on identical inputs.
Most make sense to me, although *ease of visualization* seems to be simply the inverse of the number of nodes: pangenomes with more information have more nodes and are harder to visualize but lossy approaches like the minimizer de bruijn graph are "easy" to visualize?
One big limitation to this comparative work is that PGGB and Minigraph-Cactus were run on the entire genome instead of clustering by chromosomes first. 
That can have a large impact on both the computing resources and the graph topology (basically all the aspects that this article is attempting to compare).
I'm not sure I agree with the rationale to do that.
Regarding scalability, users want to know how the tools scale *when best practices are followed*, not that it takes an order of magnitude longer when used incorrectly.
Regarding the variations missed, it's true that translocations would be dismissed but they tend to be artifacts in those assemblies (maybe a different story when building cancer pangenomes, or multi-species pangenomes).
It not clear to me what are inter-chromosomal inversions and transposable elements.

# Read alignment

In vg, there are `map`, `mpmap`.

To read: @Jain2019

## Indexing

Most mappers use a seed-and-extend approach.
For seed finding, vg indexes the graph using *GCSA2*.
In practice not all kmers can be indexed and complex regions are pruned before indexing to avoid combinatorial explosion. 

@Ghaffaari2019 developed a fast and sensitive approach for seed indexing.
In a first phase, N paths are enumerated and try to cover as many kmers as possible. 
These paths are indexed and queried using standard approaches (e.g. FM-index).
In a second phase, a chunk of reads are indexed and uncovered parts of the graphs are traversed, guided by the read index.
This avoids exploring paths absent in the reads.
PSI is as efficient as GCSA2 while being fully sensitive and not requiring any pruning.

# Variant calling

@Eggertsson2017 implemented Graphtyper, a variant caller that realigns reads in a local graph only representing a region (50 Kbp).
This approach is more accurate than standard variant calling for SNV and indels.
It seems to integrate haplotype information when genotyping.
There is no SV capability of yet.

vg implements two approaches to genotyping with commands `call` and `genotype` [@Novak2017].
`call` follows the "pileup" approach and is based on heuristic and useful to detect novel variants that can later be added to the graph (`augment` command).
More similar to FreeBayes, `genotype` tries to identify bubbles in the read paths and which side(s) of the bubble is supported.
Here each ultra-bubble is treated as a site to genotype.
In the wiki there is also a `srpe` command to quickly genotype SVs with vg but it looks experimental.

HISAT is a pain in the ass to read [@Kim2018] so I still don't know how variants are called or genotyped.

BayesTyper is a method specifically designed for variant calling using graphs [@Sibbesen2018].
Variants are clustered by distance, a graph is created for each cluster and kmer counts from reads are used to fit haplotypes from the graphs.
Some prior in a population of samples and a Gibbs sampler  are used to compute the posterior probability of haplotypes.
It can genotype any type of variants including SVs and complex variants.

ParaGRAPH is a graph-based genotyper for SVs developed by Illumina and available at [`https://github.com/Illumina/paragraph`](https://github.com/Illumina/paragraph).
The basic idea is to map reads onto a graph that contains variants and use read counts on nodes and edges to genotype the variant.
This is performed **separately for each variant**: a local graph is build and only reads mapping to the region (or having mates mapping to the region) are tested.
For long deletions, the graphs contains two regions (one for each breakpoint) with the ALT edge joining them.
The calling is done at each breakpoint separately using a maximum likelihood approach, and then merged at the variant level if consistent.
The way it is described it seems like the **graph aspect is not fully used**: only the variant to genotype is added in the graph.
And because it's done separately it is very similar to methods that compare two linear sequences (REF vs ALT).
To me the value of graph-based approaches is that it integrates many (all) variants in a region to help mapping/genotyping.

## Evaluation

ParaGRAPH uses HWE to investigate genotyping accuracy.

# Polymorphic regions

The first genome graphs were used to analyze highly polymorphic regions.
@Dilthey2015 introduced the concept of a population reference graph integrating known variants and multiple "alternate" reference sequences.
They used this approach on the MHC region of chromosome 6, with the famously polymorphic HLA region.
They built the graph with 8 alternate reference haplotypes, known HLA alleles, and ~90K SNPs.
In this proof of concept they showed that the genome inference was improved.

In @Novak2017, 5 regions  of the human genome were tested: the major histocompatibility complex (MHC), the killer cell immunoglobulin-like receptors (LRC_KIR) region, the spinal muscular atrophy (SMA) locus, and the BRCA1 and BRCA2 genes.
Genome graphs improves the amount of read mapped but especially the amount of perfect mapping.

# Haplotype modeling

@Novak2017a proposed a generalization of the PBWT (positional BWT) to genome graph, called gPBWT.
It's a compressible representation of haplotypes in a graph that can be efficiently queried.
They concluded that the haplotype information could be incorporated into graph-based read mappers.
Continuing on this haplotype representation, @Rosen2017 modeled recombination and haplotypes variation in the population.

Graphtyper may integrate haplotype information when genotyping [@Eggertsson2017].

@Siren2018 extended the pBWT to create haplotype-aware indexes.
What's the difference with the implementation from @Novak2017a?

# Reference bias

A first step toward an unbiased version of the genome was proposed with the concept of pan-genome reference [@Nguyen2015]. 
They extended the Cactus program to a set of closely related genomes.
The goal was to align genomes together and find the best ordering of the homology blocks that best represented the underlying genome.
The results is a representation of the pan-genome of the population, particularly useful for visualization, variant description and potentially read mapping.

# Annotation in the graph

@Rand2017 described different strategies to define coordinates and intervals in a graph.
Their goal was to find a good way to annotate genome graphs but in the end no final "best" solution was found.
They described concepts of XXX

# Linearization of a genome graph

- *When would it be useful to linearize a genome graph?*
- *Did @Nguyen2015 linearize their pan-genome reference?*

# Graph from de novo assemblies

The `msga` mode of vg allows to align contigs to a vg graph and integrate it.

Multiple assemblies can be aligned using Cactus [@Paten2011] and the output converted into a vg graph using [hal2vg](https://github.com/ComparativeGenomicsToolkit/hal2vg).

A new project from Erik Garrison, [seqwish](https://github.com/ekg/seqwish), has something to do with converting all-vs-all alignments into a graph.
In the command example he uses minimap2 to produce the all-vs-all alignment.
From the PAF file created, seqwish creates a gfa graph alignment file.

NovoGraph aligns multiple assemblies and produces a VCF that can then be used to create a vg graph for example [@Biederstedt2018].
Their approach starts with a pairwise alignment of each assembly with the reference genome that is then used to split the genome and guide MSA on small regions (~10 Kbp).
The MSA results are concatenated and a graph constructed from this alignment.
They used two different approaches to create the graph.
The simple approach creates a fork every time there is a change in the MSA. 
A more advanced "universal" approach tries to limit overlapping alleles (`++`).
In the end, the mean mapping identity slightly increased, the mapping rate decreased, most likely due to multi-mapped reads between duplicated regions with `MAPQ=0`.

# Tools

## danbing-tk

- DOI: 10.1038/s41467-021-24378-0
- [@lu2021nc]

1. Build a separate de bruijn graph for each VNTR site
   - include flanking "invariant" region
2. Align short reads to those repeat-pangenomes and infer VNTR length and composition
    1. Read alignment
        2. First, pick best VNTR locus based on read kmer composition (max number of kmers in common)
        3. "algorithm map the k-mers [..] such that the mapping forms a continuous path/cycle" not sure exactly how.
    4. VNTR length estimation
        5. Find reference sample with most similar kmer counts (correlation?)
    6. VNTR motif investigation using regression on different 1000GP populations

VNTR for their analysis: motif >6bp +  150bp > total length < 10kbp

## vg

In their preprint, @Garrison2017 presented the [vg](https://github.com/vgteam/vg) toolkit that provides ways to create/edit variation graphs and perform read mapping and variant calling on it.
In particular, vg scales to large genome like the human genome.

### rpvg

Spliced pangenome graph includes known splice junctions as edges, and known transcripts as paths.
Reads are mapped using mpmap, a splice-aware mapper, that produces multipath alignments to save uncertainty of an alignment to different paths.
RPVG then infers the most likely diplotype, and then quantify the expression of each transcript-haplotype pair using a expectation maximization approach.


## HISAT2

HISAT2 seems to be the main (academic) competitor to vg.
It's described in details in the HISAT-genotype preprint [@Kim2018].
After alignment with HISAT2, HISAT-genotype is supposedly able to genotype all the genes in an individual's genome within a few hours on a desktop computer.

## Seven Bridges

In their preprint, @Rakocevic2017 present the performance of their implementation of genome graphs for mapping and variant calling.
It is apparently fast and sensitive, and incorporates SVs under the "unified framework".
However, they provide no code.
`Check the updated preprint.`

## BayesTyper

BayesTyper is a method specifically designed for variant calling using graphs [@Sibbesen2018].
Variants are clustered by distance, a graph is created for each cluster and kmer counts from reads are used to fit haplotypes from the graphs.
Some prior in a population of samples and a Gibbs sampler  are used to compute the posterior probability of haplotypes.
It can genotype any type of variants including SVs and complex variants.

## Paragraph

A graph-based genotyper: [`https://github.com/Illumina/paragraph`](https://github.com/Illumina/paragraph).

## Others

FORGe is a tool that models the positive and negative effects of adding a variant to a genome graph [@Pritt2018].
On the positive side it helps alignment/calling; on the negative side it increases ambiguity and computation/storage burden.

NovoGraph aligns multiple assemblies and produces a VCF that can then be used to create a vg graph for example [@Biederstedt2018].
Their approach starts with a pairwise alignment of each assembly with the reference genome that is then used to split the genome and guide MSA on small regions (~10 Kbp).
The MSA results are concatenated and a graph constructed from this alignment.
They used two different approaches to create the graph.
The simple approach creates a fork every time there is a change in the MSA. 
A more advanced "universal" approach tries to limit overlapping alleles (`++`).
In the end, the mean mapping identity slightly increased, the mapping rate decreased, most likely due to multi-mapped reads between duplicated regions with `MAPQ=0`.


# Human pangenomes

- HPRC
    - 94 haplotypes
    - 47 individuals
- *A Pangenome Reference of 36 Chinese populations* Gao et al.
    - *A Chinese Pangenome Reference*
    - Phase I of the Chinese Pangenome Consortium (CPC)
    - 116 high-quality and haplotype-phased de novo assemblies
    - 58 core samples from 36 minority Chinese ethnic groups.
- [A Draft Pacific Ancestry Pangenome Reference](https://www.biorxiv.org/content/10.1101/2024.08.07.606392v2)
    - 23 individuals with diverse Pacific ancestry
    - phased assemblies with hifiasm from HiFi + Illumina
    - pangenomes using MC
      - 46 Pacific ancestry + GRCh38 + CHM13
      - 46 Pacific ancestry + 94 HPRC + GRCh38 + CHM13
    - +30.6Mb compared to HPRC v1
    - Small variant calls better with Pacific pangenome, and more than when combining with HPRC
        - Picked as truth sample the one with highest assembly quality (hence present in the pangenomes)
- Senegalese Genome project (SEN-GENOME)
    - [Toward building a comprehensive human pan-genome: The SEN-GENOME project (Commentary)](https://www.cell.com/ajhg/abstract/S0002-9297(24)00303-3)
    - *aims to sequence 1,000 genomes from 31 ethnolinguistic groups*
    - *SEN-GENOME seeks partnerships for the deep DNA sequencing of collected samples*

# Plant pangenomes

- Ash trees
    - [Pan-genome analyses of eleven Fraxinus species provide insights into salt adaptation in ash trees](https://pubmed.ncbi.nlm.nih.gov/39308021/)
    - *eleven high-quality chromosome-level genome assemblies for Fraxinus species*
        - Illumina + ONT
        - Canu + Racon + RagTag
    - Gene family-based pangenome?
        - PanGP v. 1.0.1 (Zhao et al., 2014) on OrthoFinder output?
    - SV-based pangenome
        1. SV detected from assemblies by aligning to the "reference" one with MUMmer, and using SyRI to identify SVs.
        1. `vg construct` to build the pangenome
    - WGS of 123 F1-progeny of a salt-tolerant x salt-sensitive species.
        - Mapped to SV-based pangenome using `vg map` and PAV called with `vg call` 
        - Then salt tolerance PAV-based quantitative trait loci (QTL)
- Bamboo
    - [Haplotype-based pangenomes reveal genetic variations and climate adaptations in moso bamboo populations](https://pubmed.ncbi.nlm.nih.gov/39278956/)
    - 16 high-quality haplotype-based pangenome assemblies of moso bamboo
        - HiFi + HiC
    - gene-based pangenome
    - Variants identified by reference-alignment based methods
    - `vg construct` to build a graph pangenome and `vg giraffe` to map short reads from 427 previously resequenced accessions
    - Identify SVs from the graph-based pangenome, guessing using `vg call`
    - SNVs/indels discovered using existing pipeline(BWA-GATK) to be comparable with previous study
    - *local climate adaptation mechanisms*
- Solanum
    - [Solanum pan-genomics and pan-genetics reveal paralogs as contingencies in crop engineering](https://www.biorxiv.org/content/10.1101/2024.09.10.612244v1.full)
    - Solanum species include eggplant (S. melongena), potato (S. tuberosum), tomato (S. lycopersicum) + indigenous crops
    - 22 species assembled with HiFi data

# Bibliography
