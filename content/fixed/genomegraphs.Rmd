---
sidebar: true
title: Genome Graphs
bibliography: [../../library-small.bib]
link-citations: true
weight: 5
output:
  blogdown::html_page:
    toc: true
---


@Paten2017 wrote a review on genome graphs covering a large number of topics.
@Marschall2018 review the emergent field of computational pan-genomics.

# Types of graphs

In @Novak2017, several genome graphs structures are compared and shown to be superior to linear representations when mapping reads.

# Read alignment

In vg, there are `map`, `mpmap`.

To read: @Jain2019

## Indexing

Most mappers use a seed-and-extend approach.
For seed finding, vg indexes the graph using *GCSA2*.
In practice not all kmers can be indexed and complex regions are pruned before indexing to avoid combinatorial explosion. 

@Ghaffaari2019 developed a fast and sensitive approach for seed indexing.
In a first phase, N paths are enumerated and try to cover as many kmers as possible. 
These paths are indexed and queried using standard approaches (e.g. FM-index).
In a second phase, a chunk of reads are indexed and uncovered parts of the graphs are traversed, guided by the read index.
This avoids exploring paths absent in the reads.
PSI is as efficient as GCSA2 while being fully sensitive and not requiring any pruning.

# Variant calling

@Eggertsson2017 implemented Graphtyper, a variant caller that realigns reads in a local graph only representing a region (50 Kbp).
This approach is more accurate than standard variant calling for SNV and indels.
It seems to integrate haplotype information when genotyping.
There is no SV capability of yet.

vg implements two approaches to genotyping with commands `call` and `genotype` [@Novak2017].
`call` follows the "pileup" approach and is based on heuristic and useful to detect novel variants that can later be added to the graph (`augment` command).
More similar to FreeBayes, `genotype` tries to identify bubbles in the read paths and which side(s) of the bubble is supported.
Here each ultra-bubble is treated as a site to genotype.
In the wiki there is also a `srpe` command to quickly genotype SVs with vg but it looks experimental.

HISAT is a pain in the ass to read [@Kim2018] so I still don't know how variants are called or genotyped.

BayesTyper is a method specifically designed for variant calling using graphs [@Sibbesen2018].
Variants are clustered by distance, a graph is created for each cluster and kmer counts from reads are used to fit haplotypes from the graphs.
Some prior in a population of samples and a Gibbs sampler  are used to compute the posterior probability of haplotypes.
It can genotype any type of variants including SVs and complex variants.

ParaGRAPH is a graph-based genotyper for SVs developed by Illumina and available at [`https://github.com/Illumina/paragraph`](https://github.com/Illumina/paragraph).
The basic idea is to map reads onto a graph that contains variants and use read counts on nodes and edges to genotype the variant.
This is performed **separately for each variant**: a local graph is build and only reads mapping to the region (or having mates mapping to the region) are tested.
For long deletions, the graphs contains two regions (one for each breakpoint) with the ALT edge joining them.
The calling is done at each breakpoint separately using a maximum likelihood approach, and then merged at the variant level if consistent.
The way it is described it seems like the **graph aspect is not fully used**: only the variant to genotype is added in the graph.
And because it's done separately it is very similar to methods that compare two linear sequences (REF vs ALT).
To me the value of graph-based approaches is that it integrates many (all) variants in a region to help mapping/genotyping.

## Evaluation

ParaGRAPH uses HWE to investigate genotyping accuracy.

# Polymorphic regions

The first genome graphs were used to analyze highly polymorphic regions.
@Dilthey2015 introduced the concept of a population reference graph integrating known variants and multiple "alternate" reference sequences.
They used this approach on the MHC region of chromosome 6, with the famously polymorphic HLA region.
They built the graph with 8 alternate reference haplotypes, known HLA alleles, and ~90K SNPs.
In this proof of concept they showed that the genome inference was improved.

In @Novak2017, 5 regions  of the human genome were tested: the major histocompatibility complex (MHC), the killer cell immunoglobulin-like receptors (LRC_KIR) region, the spinal muscular atrophy (SMA) locus, and the BRCA1 and BRCA2 genes.
Genome graphs improves the amount of read mapped but especially the amount of perfect mapping.

# Haplotype modeling

@Novak2017a proposed a generalization of the PBWT (positional BWT) to genome graph, called gPBWT.
It's a compressible representation of haplotypes in a graph that can be efficiently queried.
They concluded that the haplotype information could be incorporated into graph-based read mappers.
Continuing on this haplotype representation, @Rosen2017 modeled recombination and haplotypes variation in the population.

Graphtyper may integrate haplotype information when genotyping [@Eggertsson2017].

@Siren2018 extended the pBWT to create haplotype-aware indexes.
What's the difference with the implementation from @Novak2017a?

# Reference bias

A first step toward an unbiased version of the genome was proposed with the concept of pan-genome reference [@Nguyen2015]. 
They extended the Cactus program to a set of closely related genomes.
The goal was to align genomes together and find the best ordering of the homology blocks that best represented the underlying genome.
The results is a representation of the pan-genome of the population, particularly useful for visualization, variant description and potentially read mapping.

# Annotation in the graph

@Rand2017 described different strategies to define coordinates and intervals in a graph.
Their goal was to find a good way to annotate genome graphs but in the end no final "best" solution was found.
They described concepts of XXX

# Linearization of a genome graph

- *When would it be useful to linearize a genome graph?*
- *Did @Nguyen2015 linearize their pan-genome reference?*

# Graph from de novo assemblies

The `msga` mode of vg allows to align contigs to a vg graph and integrate it.

Multiple assemblies can be aligned using Cactus [@Paten2011] and the output converted into a vg graph using [hal2vg](https://github.com/ComparativeGenomicsToolkit/hal2vg).

A new project from Erik Garrison, [seqwish](https://github.com/ekg/seqwish), has something to do with converting all-vs-all alignments into a graph.
In the command example he uses minimap2 to produce the all-vs-all alignment.
From the PAF file created, seqwish creates a gfa graph alignment file.

NovoGraph aligns multiple assemblies and produces a VCF that can then be used to create a vg graph for example [@Biederstedt2018].
Their approach starts with a pairwise alignment of each assembly with the reference genome that is then used to split the genome and guide MSA on small regions (~10 Kbp).
The MSA results are concatenated and a graph constructed from this alignment.
They used two different approaches to create the graph.
The simple approach creates a fork every time there is a change in the MSA. 
A more advanced "universal" approach tries to limit overlapping alleles (`++`).
In the end, the mean mapping identity slightly increased, the mapping rate decreased, most likely due to multi-mapped reads between duplicated regions with `MAPQ=0`.

# Tools

## vg

In their preprint, @Garrison2017 presented the [vg](https://github.com/vgteam/vg) toolkit that provides ways to create/edit variation graphs and perform read mapping and variant calling on it.
In particular, vg scales to large genome like the human genome.

## HISAT2

HISAT2 seems to be the main (academic) competitor to vg.
It's described in details in the HISAT-genotype preprint [@Kim2018].
After alignment with HISAT2, HISAT-genotype is supposedly able to genotype all the genes in an individual's genome within a few hours on a desktop computer.

## Seven Bridges

In their preprint, @Rakocevic2017 present the performance of their implementation of genome graphs for mapping and variant calling.
It is apparently fast and sensitive, and incorporates SVs under the "unified framework".
However, they provide no code.
`Check the updated preprint.`

## BayesTyper

BayesTyper is a method specifically designed for variant calling using graphs [@Sibbesen2018].
Variants are clustered by distance, a graph is created for each cluster and kmer counts from reads are used to fit haplotypes from the graphs.
Some prior in a population of samples and a Gibbs sampler  are used to compute the posterior probability of haplotypes.
It can genotype any type of variants including SVs and complex variants.

## Paragraph

A graph-based genotyper: [`https://github.com/Illumina/paragraph`](https://github.com/Illumina/paragraph).

## Others

FORGe is a tool that models the positive and negative effects of adding a variant to a genome graph [@Pritt2018].
On the positive side it helps alignment/calling; on the negative side it increases ambiguity and computation/storage burden.

NovoGraph aligns multiple assemblies and produces a VCF that can then be used to create a vg graph for example [@Biederstedt2018].
Their approach starts with a pairwise alignment of each assembly with the reference genome that is then used to split the genome and guide MSA on small regions (~10 Kbp).
The MSA results are concatenated and a graph constructed from this alignment.
They used two different approaches to create the graph.
The simple approach creates a fork every time there is a change in the MSA. 
A more advanced "universal" approach tries to limit overlapping alleles (`++`).
In the end, the mean mapping identity slightly increased, the mapping rate decreased, most likely due to multi-mapped reads between duplicated regions with `MAPQ=0`.


# Bibliography
